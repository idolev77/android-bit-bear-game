<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/MainActivityGrid.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/MainActivityGrid.kt" />
              <option name="updatedContent" value="package com.example.myapplication.ui&#10;&#10;import android.content.Intent&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.Build&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.view.Gravity&#10;import android.view.View&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.TableLayout&#10;import android.widget.TableRow&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.bumptech.glide.Glide&#10;import com.example.myapplication.R&#10;import com.example.myapplication.logic.GameManager&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    // ===== Grid Configuration =====&#10;    private val GRID_ROWS = 8  // Number of rows in grid&#10;    private val GRID_COLS = 3  // Number of columns (lanes)&#10;    private val PLAYER_ROW = GRID_ROWS - 1  // Player is always in bottom row&#10;&#10;    // ===== UI Variables =====&#10;    private lateinit var mainLayout: android.widget.RelativeLayout&#10;    private lateinit var gameGrid: TableLayout&#10;    private lateinit var btnLeft: ImageButton&#10;    private lateinit var btnRight: ImageButton&#10;    private lateinit var textScore: TextView&#10;    private lateinit var heartViews: Array&lt;ImageView&gt;&#10;&#10;    // ===== Grid State (2D Matrix) =====&#10;    private val gridCells = Array(GRID_ROWS) { Array&lt;ImageView?&gt;(GRID_COLS) { null } }&#10;    private val gridState = Array(GRID_ROWS) { IntArray(GRID_COLS) { 0 } }  // 0=empty, 1=obstacle, 2=player&#10;&#10;    // ===== Logic =====&#10;    private lateinit var gameManager: GameManager&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val frameRate: Long = 500 // Move every 500ms (discrete jumps)&#10;&#10;    // Obstacle tracking&#10;    private var obstacleRow = 0&#10;    private var obstacleCol = 1  // Start in center column&#10;    private var collisionDetected = false&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main_grid)&#10;&#10;        // Force LTR layout direction&#10;        window.decorView.layoutDirection = View.LAYOUT_DIRECTION_LTR&#10;&#10;        initViews()&#10;        buildGrid()&#10;        initGame()&#10;    }&#10;&#10;    // ===== View Initialization =====&#10;    private fun initViews() {&#10;        mainLayout = findViewById(R.id.main_layout)&#10;        gameGrid = findViewById(R.id.game_grid)&#10;        btnLeft = findViewById(R.id.btn_left)&#10;        btnRight = findViewById(R.id.btn_right)&#10;        textScore = findViewById(R.id.text_score)&#10;&#10;        // Load animated GIF background&#10;        val backgroundGif = findViewById&lt;ImageView&gt;(R.id.background_gif)&#10;        Glide.with(this)&#10;            .asGif()&#10;            .load(R.drawable.tenor)&#10;            .into(backgroundGif)&#10;&#10;        heartViews = arrayOf(&#10;            findViewById(R.id.heart1),&#10;            findViewById(R.id.heart2),&#10;            findViewById(R.id.heart3)&#10;        )&#10;    }&#10;&#10;    // ===== Build Grid Dynamically =====&#10;    private fun buildGrid() {&#10;        gameGrid.removeAllViews()&#10;&#10;        for (row in 0 until GRID_ROWS) {&#10;            val tableRow = TableRow(this).apply {&#10;                layoutParams = TableLayout.LayoutParams(&#10;                    TableLayout.LayoutParams.MATCH_PARENT,&#10;                    0,&#10;                    1f  // Equal weight for all rows&#10;                )&#10;            }&#10;&#10;            for (col in 0 until GRID_COLS) {&#10;                val cell = ImageView(this).apply {&#10;                    layoutParams = TableRow.LayoutParams(&#10;                        0,&#10;                        TableRow.LayoutParams.MATCH_PARENT,&#10;                        1f  // Equal weight for all columns&#10;                    )&#10;                    scaleType = ImageView.ScaleType.FIT_CENTER&#10;                    setPadding(8, 8, 8, 8)&#10;                    &#10;                    // Debug: Show grid borders (optional - comment out for production)&#10;                    // setBackgroundColor(Color.argb(50, 255, 255, 255))&#10;                }&#10;&#10;                gridCells[row][col] = cell&#10;                tableRow.addView(cell)&#10;            }&#10;&#10;            gameGrid.addView(tableRow)&#10;        }&#10;    }&#10;&#10;    private fun initGame() {&#10;        gameManager = GameManager()&#10;&#10;        // Place player in center of bottom row&#10;        placePlayer()&#10;&#10;        // Place first obstacle&#10;        placeObstacle()&#10;&#10;        btnLeft.setOnClickListener {&#10;            gameManager.moveCarLeft()&#10;            updatePlayerPosition()&#10;        }&#10;&#10;        btnRight.setOnClickListener {&#10;            gameManager.moveCarRight()&#10;            updatePlayerPosition()&#10;        }&#10;&#10;        updatePlayerPosition()&#10;        updateLivesUI()&#10;        updateScoreUI()&#10;        startTimer()&#10;    }&#10;&#10;    // ===== Place Player in Grid =====&#10;    private fun placePlayer() {&#10;        // Clear previous player position&#10;        for (col in 0 until GRID_COLS) {&#10;            gridState[PLAYER_ROW][col] = 0&#10;            gridCells[PLAYER_ROW][col]?.setImageDrawable(null)&#10;        }&#10;&#10;        // Place player in current column&#10;        val playerCol = gameManager.currentCarIndex&#10;        gridState[PLAYER_ROW][playerCol] = 2&#10;        gridCells[PLAYER_ROW][playerCol]?.setImageResource(R.drawable.bitcoin)&#10;    }&#10;&#10;    // ===== Place Obstacle in Grid =====&#10;    private fun placeObstacle() {&#10;        obstacleRow = 0&#10;        obstacleCol = (0 until GRID_COLS).random()&#10;        gridState[obstacleRow][obstacleCol] = 1&#10;        gridCells[obstacleRow][obstacleCol]?.setImageResource(R.drawable.bear)&#10;        collisionDetected = false&#10;    }&#10;&#10;    // ===== Game Loop =====&#10;    private val runnable = object : Runnable {&#10;        override fun run() {&#10;            handler.postDelayed(this, frameRate)&#10;            tick()&#10;        }&#10;    }&#10;&#10;    private fun startTimer() {&#10;        handler.post(runnable)&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        handler.removeCallbacks(runnable)&#10;    }&#10;&#10;    // ===== Game Tick (Discrete Grid Movement) =====&#10;    private fun tick() {&#10;        if (!gameManager.isGameRunning) {&#10;            stopTimer()&#10;            openGameOverActivity()&#10;            return&#10;        }&#10;&#10;        moveObstacleInGrid()&#10;        checkCollisionInGrid()&#10;        updateLivesUI()&#10;        updateScoreUI()&#10;    }&#10;&#10;    // ===== Grid-based Obstacle Movement =====&#10;    private fun moveObstacleInGrid() {&#10;        // Clear current obstacle position&#10;        gridCells[obstacleRow][obstacleCol]?.setImageDrawable(null)&#10;        gridState[obstacleRow][obstacleCol] = 0&#10;&#10;        // Move obstacle down one row (discrete jump)&#10;        obstacleRow++&#10;&#10;        // Check if obstacle reached bottom&#10;        if (obstacleRow &gt;= GRID_ROWS) {&#10;            // Obstacle successfully passed - check if dodged&#10;            if (!collisionDetected) {&#10;                gameManager.incrementScore()&#10;            }&#10;            &#10;            // Reset obstacle to top&#10;            placeObstacle()&#10;            return&#10;        }&#10;&#10;        // Place obstacle in new position&#10;        gridState[obstacleRow][obstacleCol] = 1&#10;        gridCells[obstacleRow][obstacleCol]?.setImageResource(R.drawable.bear)&#10;    }&#10;&#10;    // ===== Grid-based Collision Detection =====&#10;    private fun checkCollisionInGrid() {&#10;        if (collisionDetected) return&#10;&#10;        // Check if obstacle is in same position as player&#10;        val playerCol = gameManager.currentCarIndex&#10;        &#10;        if (obstacleRow == PLAYER_ROW &amp;&amp; obstacleCol == playerCol) {&#10;            collisionDetected = true&#10;            onCrash()&#10;            gameManager.checkCollision(obstacleCol)&#10;        }&#10;    }&#10;&#10;    // ===== UI Updates =====&#10;    private fun updatePlayerPosition() {&#10;        placePlayer()&#10;    }&#10;&#10;    private fun updateLivesUI() {&#10;        for (i in heartViews.indices) {&#10;            heartViews[i].visibility = if (i &lt; gameManager.lives) View.VISIBLE else View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    private fun updateScoreUI() {&#10;        textScore.text = getString(R.string.score_label, gameManager.score)&#10;    }&#10;&#10;    private fun openGameOverActivity() {&#10;        val intent = Intent(this, GameOverActivity::class.java)&#10;        intent.putExtra(&quot;FINAL_SCORE&quot;, gameManager.score)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    // ===== Crash Handler =====&#10;    private fun onCrash() {&#10;        Toast.makeText(this, &quot;Crash!&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;        val vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = getSystemService(VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;        vibrator.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE))&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        stopTimer()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::gameManager.isInitialized &amp;&amp; gameManager.isGameRunning) {&#10;            startTimer()&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/MainActivity_grid_clean.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/MainActivity_grid_clean.kt" />
              <option name="updatedContent" value="package com.example.myapplication.ui&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.Build&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.TableLayout&#10;import android.widget.TableRow&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.bumptech.glide.Glide&#10;import com.example.myapplication.R&#10;import com.example.myapplication.logic.GameManager&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    // ===== Grid Configuration =====&#10;    private val GRID_ROWS = 7&#10;    private val GRID_COLS = 3&#10;    private val PLAYER_ROW = GRID_ROWS - 1&#10;&#10;    // ===== UI Variables =====&#10;    private lateinit var gameGrid: TableLayout&#10;    private lateinit var btnLeft: ImageButton&#10;    private lateinit var btnRight: ImageButton&#10;    private lateinit var textScore: TextView&#10;    private lateinit var heartViews: Array&lt;ImageView&gt;&#10;&#10;    // ===== Grid Cells =====&#10;    private val gridCells = Array(GRID_ROWS) { row -&gt;&#10;        Array&lt;ImageView?&gt;(GRID_COLS) { null }&#10;    }&#10;&#10;    // ===== Logic =====&#10;    private lateinit var gameManager: GameManager&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val frameRate: Long = 600 // Move every 0.6 seconds&#10;&#10;    // Obstacle tracking&#10;    private var obstacleRow = -1&#10;    private var obstacleCol = 1&#10;    private var collisionDetected = false&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;&#10;        // Force LTR&#10;        window.decorView.layoutDirection = View.LAYOUT_DIRECTION_LTR&#10;&#10;        initViews()&#10;        buildGrid()&#10;        initGame()&#10;    }&#10;&#10;    private fun initViews() {&#10;        gameGrid = findViewById(R.id.game_grid)&#10;        btnLeft = findViewById(R.id.btn_left)&#10;        btnRight = findViewById(R.id.btn_right)&#10;        textScore = findViewById(R.id.text_score)&#10;&#10;        // Load GIF background&#10;        val backgroundGif = findViewById&lt;ImageView&gt;(R.id.background_gif)&#10;        Glide.with(this)&#10;            .asGif()&#10;            .load(R.drawable.tenor)&#10;            .into(backgroundGif)&#10;&#10;        heartViews = arrayOf(&#10;            findViewById(R.id.heart1),&#10;            findViewById(R.id.heart2),&#10;            findViewById(R.id.heart3)&#10;        )&#10;    }&#10;&#10;    private fun buildGrid() {&#10;        gameGrid.removeAllViews()&#10;&#10;        // Calculate cell size&#10;        val displayMetrics = resources.displayMetrics&#10;        val screenWidth = displayMetrics.widthPixels&#10;        val screenHeight = displayMetrics.heightPixels&#10;        &#10;        val availableHeight = screenHeight - 400 // Leave space for UI&#10;        val cellHeight = availableHeight / GRID_ROWS&#10;        val cellWidth = (screenWidth - 80) / GRID_COLS&#10;&#10;        for (row in 0 until GRID_ROWS) {&#10;            val tableRow = TableRow(this).apply {&#10;                layoutParams = TableLayout.LayoutParams(&#10;                    TableLayout.LayoutParams.MATCH_PARENT,&#10;                    cellHeight&#10;                )&#10;            }&#10;&#10;            for (col in 0 until GRID_COLS) {&#10;                val cell = ImageView(this).apply {&#10;                    layoutParams = TableRow.LayoutParams(&#10;                        cellWidth,&#10;                        ViewGroup.LayoutParams.MATCH_PARENT&#10;                    )&#10;                    scaleType = ImageView.ScaleType.FIT_CENTER&#10;                    setPadding(4, 4, 4, 4)&#10;                }&#10;&#10;                gridCells[row][col] = cell&#10;                tableRow.addView(cell)&#10;            }&#10;&#10;            gameGrid.addView(tableRow)&#10;        }&#10;    }&#10;&#10;    private fun initGame() {&#10;        gameManager = GameManager()&#10;&#10;        btnLeft.setOnClickListener {&#10;            gameManager.moveCarLeft()&#10;            updatePlayerPosition()&#10;        }&#10;&#10;        btnRight.setOnClickListener {&#10;            gameManager.moveCarRight()&#10;            updatePlayerPosition()&#10;        }&#10;&#10;        updatePlayerPosition()&#10;        updateLivesUI()&#10;        updateScoreUI()&#10;        spawnNewObstacle()&#10;        startTimer()&#10;    }&#10;&#10;    // ===== Game Loop =====&#10;    private val runnable = object : Runnable {&#10;        override fun run() {&#10;            if (gameManager.isGameRunning) {&#10;                handler.postDelayed(this, frameRate)&#10;                tick()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startTimer() {&#10;        handler.postDelayed(runnable, frameRate)&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        handler.removeCallbacks(runnable)&#10;    }&#10;&#10;    private fun tick() {&#10;        if (!gameManager.isGameRunning) {&#10;            stopTimer()&#10;            openGameOverActivity()&#10;            return&#10;        }&#10;&#10;        moveObstacle()&#10;        updateScoreUI()&#10;        updateLivesUI()&#10;    }&#10;&#10;    private fun spawnNewObstacle() {&#10;        obstacleRow = 0&#10;        obstacleCol = (0 until GRID_COLS).random()&#10;        collisionDetected = false&#10;        &#10;        // Place obstacle in grid&#10;        gridCells[obstacleRow][obstacleCol]?.setImageResource(R.drawable.bear)&#10;    }&#10;&#10;    private fun moveObstacle() {&#10;        if (obstacleRow &lt; 0) return&#10;&#10;        // Clear current position&#10;        if (obstacleRow &lt; GRID_ROWS) {&#10;            gridCells[obstacleRow][obstacleCol]?.setImageDrawable(null)&#10;        }&#10;&#10;        // Move down one row&#10;        obstacleRow++&#10;&#10;        // Check if reached bottom&#10;        if (obstacleRow &gt;= GRID_ROWS) {&#10;            // Obstacle passed successfully&#10;            if (!collisionDetected) {&#10;                gameManager.incrementScore()&#10;            }&#10;            spawnNewObstacle()&#10;            return&#10;        }&#10;&#10;        // Check collision BEFORE placing&#10;        if (obstacleRow == PLAYER_ROW &amp;&amp; obstacleCol == gameManager.currentCarIndex) {&#10;            // Collision!&#10;            collisionDetected = true&#10;            onCrash()&#10;            gameManager.checkCollision(obstacleCol)&#10;            &#10;            // Skip placing obstacle (it crashed)&#10;            spawnNewObstacle()&#10;            return&#10;        }&#10;&#10;        // Place obstacle in new position&#10;        gridCells[obstacleRow][obstacleCol]?.setImageResource(R.drawable.bear)&#10;    }&#10;&#10;    private fun updatePlayerPosition() {&#10;        // Clear all player positions&#10;        for (col in 0 until GRID_COLS) {&#10;            gridCells[PLAYER_ROW][col]?.setImageDrawable(null)&#10;        }&#10;&#10;        // Place player in current lane&#10;        val playerCol = gameManager.currentCarIndex&#10;        gridCells[PLAYER_ROW][playerCol]?.setImageResource(R.drawable.bitcoin)&#10;    }&#10;&#10;    private fun updateLivesUI() {&#10;        for (i in heartViews.indices) {&#10;            heartViews[i].visibility = if (i &lt; gameManager.lives) View.VISIBLE else View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    private fun updateScoreUI() {&#10;        textScore.text = getString(R.string.score_label, gameManager.score)&#10;    }&#10;&#10;    private fun onCrash() {&#10;        Toast.makeText(this, &quot;Crash!&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;        val vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = getSystemService(VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;        vibrator.vibrate(VibrationEffect.createOneShot(300, VibrationEffect.DEFAULT_AMPLITUDE))&#10;    }&#10;&#10;    private fun openGameOverActivity() {&#10;        val intent = Intent(this, GameOverActivity::class.java)&#10;        intent.putExtra(&quot;FINAL_SCORE&quot;, gameManager.score)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        stopTimer()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::gameManager.isInitialized &amp;&amp; gameManager.isGameRunning) {&#10;            startTimer()&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/cell_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/cell_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;!-- Semi-transparent white background --&gt;&#10;    &lt;solid android:color=&quot;#66FFFFFF&quot; /&gt;&#10;    &#10;    &lt;!-- Rounded corners --&gt;&#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;    &#10;    &lt;!-- Border for more emphasis --&gt;&#10;    &lt;stroke&#10;        android:width=&quot;2dp&quot;&#10;        android:color=&quot;#99FFFFFF&quot; /&gt;&#10;    &#10;    &lt;!-- Padding inside --&gt;&#10;    &lt;padding&#10;        android:left=&quot;4dp&quot;&#10;        android:top=&quot;4dp&quot;&#10;        android:right=&quot;4dp&quot;&#10;        android:bottom=&quot;4dp&quot; /&gt;&#10;&lt;/shape&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_main_grid.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_main_grid.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main_layout&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:layoutDirection=&quot;ltr&quot;&#10;    tools:context=&quot;.ui.MainActivity&quot;&gt;&#10;&#10;    &lt;!-- ===== ANIMATED GIF BACKGROUND ===== --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/background_gif&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:scaleType=&quot;centerCrop&quot;&#10;        android:contentDescription=&quot;@string/background_description&quot;/&gt;&#10;&#10;    &lt;!-- ===== SCORE (TOP LEFT) ===== --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_score&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_alignParentTop=&quot;true&quot;&#10;        android:layout_alignParentLeft=&quot;true&quot;&#10;        android:layout_margin=&quot;@dimen/screen_margin&quot;&#10;        android:background=&quot;@drawable/hearts_background&quot;&#10;        android:padding=&quot;12dp&quot;&#10;        android:text=&quot;@string/score_label&quot;&#10;        android:textColor=&quot;#FFFFFF&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:elevation=&quot;10dp&quot;&#10;        android:contentDescription=&quot;@string/score_description&quot;/&gt;&#10;&#10;    &lt;!-- ===== LIVES (TOP RIGHT) ===== --&gt;&#10;    &lt;RelativeLayout&#10;        android:id=&quot;@+id/panel_hearts&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_alignParentTop=&quot;true&quot;&#10;        android:layout_alignParentRight=&quot;true&quot;&#10;        android:layout_margin=&quot;@dimen/screen_margin&quot;&#10;        android:background=&quot;@drawable/hearts_background&quot;&#10;        android:padding=&quot;8dp&quot;&#10;        android:elevation=&quot;10dp&quot;&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/heart3&quot;&#10;            android:layout_width=&quot;@dimen/heart_size&quot;&#10;            android:layout_height=&quot;@dimen/heart_size&quot;&#10;            android:src=&quot;@drawable/heart&quot;&#10;            android:layout_toRightOf=&quot;@id/heart2&quot;&#10;            android:contentDescription=&quot;@string/heart_description&quot;/&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/heart2&quot;&#10;            android:layout_width=&quot;@dimen/heart_size&quot;&#10;            android:layout_height=&quot;@dimen/heart_size&quot;&#10;            android:src=&quot;@drawable/heart&quot;&#10;            android:layout_toRightOf=&quot;@id/heart1&quot;&#10;            android:layout_marginLeft=&quot;@dimen/lane_margin&quot;&#10;            android:contentDescription=&quot;@string/heart_description&quot;/&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/heart1&quot;&#10;            android:layout_width=&quot;@dimen/heart_size&quot;&#10;            android:layout_height=&quot;@dimen/heart_size&quot;&#10;            android:src=&quot;@drawable/heart&quot;&#10;            android:contentDescription=&quot;@string/heart_description&quot;/&gt;&#10;    &lt;/RelativeLayout&gt;&#10;&#10;    &lt;!-- ===== GRID GAME AREA ===== --&gt;&#10;    &lt;TableLayout&#10;        android:id=&quot;@+id/game_grid&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:layout_centerInParent=&quot;true&quot;&#10;        android:stretchColumns=&quot;*&quot;&#10;        android:shrinkColumns=&quot;*&quot;&gt;&#10;        &#10;        &lt;!-- Grid rows will be added dynamically in code --&gt;&#10;    &lt;/TableLayout&gt;&#10;&#10;    &lt;!-- ===== CONTROLS (FLOATING OVERLAY) ===== --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/btn_left&quot;&#10;        android:layout_width=&quot;@dimen/button_size&quot;&#10;        android:layout_height=&quot;@dimen/button_size&quot;&#10;        android:layout_alignParentBottom=&quot;true&quot;&#10;        android:layout_alignParentLeft=&quot;true&quot;&#10;        android:layout_margin=&quot;@dimen/button_bottom_margin&quot;&#10;        android:layout_marginLeft=&quot;@dimen/screen_margin&quot;&#10;        android:background=&quot;@drawable/button_background&quot;&#10;        android:src=&quot;@android:drawable/ic_media_previous&quot;&#10;        android:elevation=&quot;10dp&quot;&#10;        android:contentDescription=&quot;@string/button_left_description&quot;/&gt;&#10;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/btn_right&quot;&#10;        android:layout_width=&quot;@dimen/button_size&quot;&#10;        android:layout_height=&quot;@dimen/button_size&quot;&#10;        android:layout_alignParentBottom=&quot;true&quot;&#10;        android:layout_alignParentRight=&quot;true&quot;&#10;        android:layout_margin=&quot;@dimen/button_bottom_margin&quot;&#10;        android:layout_marginRight=&quot;@dimen/screen_margin&quot;&#10;        android:background=&quot;@drawable/button_background&quot;&#10;        android:src=&quot;@android:drawable/ic_media_next&quot;&#10;        android:elevation=&quot;10dp&quot;&#10;        android:contentDescription=&quot;@string/button_right_description&quot;/&gt;&#10;&#10;&lt;/RelativeLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>