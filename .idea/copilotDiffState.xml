<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/MainActivity.kt" />
              <option name="originalContent" value="package com.example.myapplication.ui&#10;&#10;import android.content.Context&#10;import android.graphics.Rect&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.Build&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.view.View&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.RelativeLayout&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.bumptech.glide.Glide&#10;import com.example.myapplication.R&#10;import com.example.myapplication.logic.GameManager&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    // ===== UI Variables =====&#10;    private lateinit var mainLayout: RelativeLayout&#10;    private lateinit var btnLeft: ImageButton&#10;    private lateinit var btnRight: ImageButton&#10;&#10;    // View arrays to control lanes easily&#10;    private lateinit var carViews: Array&lt;ImageView&gt;&#10;    private lateinit var obstacleViews: Array&lt;ImageView&gt;&#10;    private lateinit var heartViews: Array&lt;ImageView&gt;&#10;&#10;    // ===== Logic =====&#10;    private lateinit var gameManager: GameManager&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val frameRate: Long = 30 // Refresh rate (ms)&#10;&#10;    // Obstacle data&#10;    private var activeObstacleLane = 1 // Which obstacle is currently falling&#10;    private var obstacleSpeed = 20&#10;    private var collisionDetected = false // Prevent double collision&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;&#10;        initViews()&#10;        initGame()&#10;    }&#10;&#10;    // ===== View Initialization =====&#10;    private fun initViews() {&#10;        mainLayout = findViewById(R.id.main_layout)&#10;        btnLeft = findViewById(R.id.btn_left)&#10;        btnRight = findViewById(R.id.btn_right)&#10;&#10;        // Load animated GIF background with Glide&#10;        val backgroundGif = findViewById&lt;ImageView&gt;(R.id.background_gif)&#10;        Glide.with(this)&#10;            .asGif()&#10;            .load(R.drawable.tenor)&#10;            .into(backgroundGif)&#10;&#10;        carViews = arrayOf(&#10;            findViewById(R.id.car_left),&#10;            findViewById(R.id.car_center),&#10;            findViewById(R.id.car_right)&#10;        )&#10;&#10;        obstacleViews = arrayOf(&#10;            findViewById(R.id.obstacle_left),&#10;            findViewById(R.id.obstacle_center),&#10;            findViewById(R.id.obstacle_right)&#10;        )&#10;&#10;        heartViews = arrayOf(&#10;            findViewById(R.id.heart1),&#10;            findViewById(R.id.heart2),&#10;            findViewById(R.id.heart3)&#10;        )&#10;&#10;        // Hide all obstacles initially&#10;        for (obs in obstacleViews) {&#10;            obs.visibility = View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    private fun initGame() {&#10;        gameManager = GameManager(this)&#10;&#10;        btnLeft.setOnClickListener {&#10;            gameManager.moveCarLeft()&#10;            updateCarUI()&#10;        }&#10;&#10;        btnRight.setOnClickListener {&#10;            gameManager.moveCarRight()&#10;            updateCarUI()&#10;        }&#10;&#10;        updateCarUI() // Show initial car position&#10;        updateLivesUI() // Show initial lives&#10;        startTimer()&#10;    }&#10;&#10;    // ===== Game Loop =====&#10;    private val runnable = object : Runnable {&#10;        override fun run() {&#10;            handler.postDelayed(this, frameRate)&#10;            tick()&#10;        }&#10;    }&#10;&#10;    private fun startTimer() {&#10;        handler.post(runnable)&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        handler.removeCallbacks(runnable)&#10;    }&#10;&#10;    // ===== Constant Updates =====&#10;    private fun tick() {&#10;        if (!gameManager.isGameRunning) {&#10;            stopTimer()&#10;            return&#10;        }&#10;&#10;        moveObstacle()&#10;        checkCollision()&#10;        updateLivesUI()&#10;    }&#10;&#10;    private fun moveObstacle() {&#10;        // Select active obstacle and update its topMargin&#10;        val obstacle = obstacleViews[activeObstacleLane]&#10;&#10;        // Ensure obstacle is visible&#10;        if (obstacle.visibility != View.VISIBLE) {&#10;            obstacle.visibility = View.VISIBLE&#10;            // Reset position to top&#10;            val params = obstacle.layoutParams as RelativeLayout.LayoutParams&#10;            params.topMargin = -200&#10;            obstacle.layoutParams = params&#10;        }&#10;&#10;        // Change Margin (Simulating Y movement)&#10;        val params = obstacle.layoutParams as RelativeLayout.LayoutParams&#10;        params.topMargin += obstacleSpeed&#10;&#10;        // If obstacle goes off screen&#10;        if (params.topMargin &gt; mainLayout.height) {&#10;            params.topMargin = -200&#10;            obstacle.visibility = View.INVISIBLE&#10;            // Pick a new random lane&#10;            activeObstacleLane = (0..2).random()&#10;            collisionDetected = false // Reset for new obstacle&#10;        }&#10;&#10;        obstacle.layoutParams = params&#10;    }&#10;&#10;    // ===== UI Updates =====&#10;    private fun updateCarUI() {&#10;        // Show only the car in the current lane&#10;        for (i in carViews.indices) {&#10;            if (i == gameManager.currentCarIndex) {&#10;                carViews[i].visibility = View.VISIBLE&#10;            } else {&#10;                carViews[i].visibility = View.INVISIBLE&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateLivesUI() {&#10;        // Hide hearts based on life count&#10;        for (i in heartViews.indices) {&#10;            heartViews[i].visibility = if (i &lt; gameManager.lives) View.VISIBLE else View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    // ===== Collision Detection =====&#10;    private fun checkCollision() {&#10;        if (collisionDetected) return // Already handled this obstacle&#10;&#10;        val car = carViews[gameManager.currentCarIndex]&#10;        val obstacle = obstacleViews[activeObstacleLane]&#10;&#10;        // Only check if obstacle is visible&#10;        if (obstacle.visibility != View.VISIBLE) return&#10;&#10;        // Use global screen coordinates for accurate detection&#10;        val carLocation = IntArray(2)&#10;        val obstacleLocation = IntArray(2)&#10;&#10;        car.getLocationOnScreen(carLocation)&#10;        obstacle.getLocationOnScreen(obstacleLocation)&#10;&#10;        val carRect = Rect(&#10;            carLocation[0],&#10;            carLocation[1],&#10;            carLocation[0] + car.width,&#10;            carLocation[1] + car.height&#10;        )&#10;&#10;        val obstacleRect = Rect(&#10;            obstacleLocation[0],&#10;            obstacleLocation[1],&#10;            obstacleLocation[0] + obstacle.width,&#10;            obstacleLocation[1] + obstacle.height&#10;        )&#10;&#10;        if (Rect.intersects(carRect, obstacleRect)) {&#10;            // Collision detected&#10;            collisionDetected = true&#10;            onCrash() // Show toast and vibrate&#10;            gameManager.checkCollision(activeObstacleLane)&#10;&#10;            // Move obstacle away immediately to prevent double detection&#10;            val params = obstacle.layoutParams as RelativeLayout.LayoutParams&#10;            params.topMargin = mainLayout.height + 100&#10;            obstacle.layoutParams = params&#10;        }&#10;    }&#10;&#10;    // ===== Crash Handler =====&#10;    private fun onCrash() {&#10;        // Display Toast message&#10;        Toast.makeText(this, &quot;Crash!&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;        // Trigger vibration&#10;        val vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;        vibrator.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE))&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        stopTimer()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        startTimer()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.myapplication.ui&#10;&#10;import android.content.Context&#10;import android.graphics.Rect&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.Build&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.view.View&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.RelativeLayout&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.bumptech.glide.Glide&#10;import com.example.myapplication.R&#10;import com.example.myapplication.logic.GameManager&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    // ===== UI Variables =====&#10;    private lateinit var mainLayout: RelativeLayout&#10;    private lateinit var btnLeft: ImageButton&#10;    private lateinit var btnRight: ImageButton&#10;&#10;    // View arrays to control lanes easily&#10;    private lateinit var carViews: Array&lt;ImageView&gt;&#10;    private lateinit var obstacleViews: Array&lt;ImageView&gt;&#10;    private lateinit var heartViews: Array&lt;ImageView&gt;&#10;&#10;    // ===== Logic =====&#10;    private lateinit var gameManager: GameManager&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val frameRate: Long = 30 // Refresh rate (ms)&#10;&#10;    // Obstacle data&#10;    private var activeObstacleLane = 1 // Which obstacle is currently falling&#10;    private var obstacleSpeed = 20&#10;    private var collisionDetected = false // Prevent double collision&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;&#10;        initViews()&#10;        initGame()&#10;    }&#10;&#10;    // ===== View Initialization =====&#10;    private fun initViews() {&#10;        mainLayout = findViewById(R.id.main_layout)&#10;        btnLeft = findViewById(R.id.btn_left)&#10;        btnRight = findViewById(R.id.btn_right)&#10;&#10;        // Load animated GIF background with Glide&#10;        val backgroundGif = findViewById&lt;ImageView&gt;(R.id.background_gif)&#10;        Glide.with(this)&#10;            .asGif()&#10;            .load(R.drawable.tenor)&#10;            .into(backgroundGif)&#10;&#10;        carViews = arrayOf(&#10;            findViewById(R.id.car_left),&#10;            findViewById(R.id.car_center),&#10;            findViewById(R.id.car_right)&#10;        )&#10;&#10;        obstacleViews = arrayOf(&#10;            findViewById(R.id.obstacle_left),&#10;            findViewById(R.id.obstacle_center),&#10;            findViewById(R.id.obstacle_right)&#10;        )&#10;&#10;        heartViews = arrayOf(&#10;            findViewById(R.id.heart1),&#10;            findViewById(R.id.heart2),&#10;            findViewById(R.id.heart3)&#10;        )&#10;&#10;        // Hide all obstacles initially&#10;        for (obs in obstacleViews) {&#10;            obs.visibility = View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    private fun initGame() {&#10;        gameManager = GameManager(this)&#10;&#10;        btnLeft.setOnClickListener {&#10;            gameManager.moveCarLeft()&#10;            updateCarUI()&#10;        }&#10;&#10;        btnRight.setOnClickListener {&#10;            gameManager.moveCarRight()&#10;            updateCarUI()&#10;        }&#10;&#10;        updateCarUI() // Show initial car position&#10;        updateLivesUI() // Show initial lives&#10;        startTimer()&#10;    }&#10;&#10;    // ===== Game Loop =====&#10;    private val runnable = object : Runnable {&#10;        override fun run() {&#10;            handler.postDelayed(this, frameRate)&#10;            tick()&#10;        }&#10;    }&#10;&#10;    private fun startTimer() {&#10;        handler.post(runnable)&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        handler.removeCallbacks(runnable)&#10;    }&#10;&#10;    // ===== Constant Updates =====&#10;    private fun tick() {&#10;        if (!gameManager.isGameRunning) {&#10;            stopTimer()&#10;            return&#10;        }&#10;&#10;        moveObstacle()&#10;        checkCollision()&#10;        updateLivesUI()&#10;    }&#10;&#10;    private fun moveObstacle() {&#10;        // Select active obstacle and update its topMargin&#10;        val obstacle = obstacleViews[activeObstacleLane]&#10;&#10;        // Ensure obstacle is visible&#10;        if (obstacle.visibility != View.VISIBLE) {&#10;            obstacle.visibility = View.VISIBLE&#10;            // Reset position to top&#10;            val params = obstacle.layoutParams as RelativeLayout.LayoutParams&#10;            params.topMargin = -200&#10;            obstacle.layoutParams = params&#10;        }&#10;&#10;        // Change Margin (Simulating Y movement)&#10;        val params = obstacle.layoutParams as RelativeLayout.LayoutParams&#10;        params.topMargin += obstacleSpeed&#10;&#10;        // If obstacle goes off screen&#10;        if (params.topMargin &gt; mainLayout.height) {&#10;            params.topMargin = -200&#10;            obstacle.visibility = View.INVISIBLE&#10;            // Pick a new random lane&#10;            activeObstacleLane = (0..2).random()&#10;            collisionDetected = false // Reset for new obstacle&#10;        }&#10;&#10;        obstacle.layoutParams = params&#10;    }&#10;&#10;    // ===== UI Updates =====&#10;    private fun updateCarUI() {&#10;        // Show only the car in the current lane&#10;        for (i in carViews.indices) {&#10;            if (i == gameManager.currentCarIndex) {&#10;                carViews[i].visibility = View.VISIBLE&#10;            } else {&#10;                carViews[i].visibility = View.INVISIBLE&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateLivesUI() {&#10;        // Hide hearts based on life count&#10;        for (i in heartViews.indices) {&#10;            heartViews[i].visibility = if (i &lt; gameManager.lives) View.VISIBLE else View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    // ===== Collision Detection =====&#10;    private fun checkCollision() {&#10;        if (collisionDetected) return // Already handled this obstacle&#10;&#10;        val car = carViews[gameManager.currentCarIndex]&#10;        val obstacle = obstacleViews[activeObstacleLane]&#10;&#10;        // Only check if obstacle is visible&#10;        if (obstacle.visibility != View.VISIBLE) return&#10;&#10;        // Use global screen coordinates for accurate detection&#10;        val carLocation = IntArray(2)&#10;        val obstacleLocation = IntArray(2)&#10;&#10;        car.getLocationOnScreen(carLocation)&#10;        obstacle.getLocationOnScreen(obstacleLocation)&#10;&#10;        val carRect = Rect(&#10;            carLocation[0],&#10;            carLocation[1],&#10;            carLocation[0] + car.width,&#10;            carLocation[1] + car.height&#10;        )&#10;&#10;        val obstacleRect = Rect(&#10;            obstacleLocation[0],&#10;            obstacleLocation[1],&#10;            obstacleLocation[0] + obstacle.width,&#10;            obstacleLocation[1] + obstacle.height&#10;        )&#10;&#10;        if (Rect.intersects(carRect, obstacleRect)) {&#10;            // Collision detected&#10;            collisionDetected = true&#10;            onCrash() // Show toast and vibrate&#10;            gameManager.checkCollision(activeObstacleLane)&#10;&#10;            // Move obstacle away immediately to prevent double detection&#10;            val params = obstacle.layoutParams as RelativeLayout.LayoutParams&#10;            params.topMargin = mainLayout.height + 100&#10;            obstacle.layoutParams = params&#10;        }&#10;    }&#10;&#10;    // ===== Crash Handler =====&#10;    private fun onCrash() {&#10;        // Display Toast message&#10;        Toast.makeText(this, &quot;Crash!&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;        // Trigger vibration&#10;        val vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = getSystemService(VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;        vibrator.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE))&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        stopTimer()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        startTimer()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>